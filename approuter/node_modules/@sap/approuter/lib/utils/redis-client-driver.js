'use strict';

const tracer = require('../utils/logger').getTracer(__filename);
const Redis = require('ioredis');
const REDIS_SCALE_READS = process.env.REDIS_SCALE_READS || 'all';
const vcapUtils = require('../utils/vcap-utils');

const DEFAULT_RETRY_TIMEOUT = 2000;
const RETRY_TIMEOUT_MULTIPLIER = 50;

class RedisClientDriver {
  constructor(credentials) {
    this.credentials = credentials;
    this.init();
  }

  init() {
    try {
      this.client = this.credentials.cluster_mode ? this.initializeClusterClient() : this.initializeClient();
      this.client.on('error', (err) => {
        tracer.error(`initClient - Redis connection error, err.code ${ err.code }, err: ${ JSON.stringify(err) }`);
        if (err && err.code === 'ECONNREFUSED') {
          tracer.error('initClient - onError - The server refused the connection');
        }
      });
      this.client.on('connect', () => {
        tracer.debug('initClient - Redis connected');
      });
    } catch (err) {
      tracer.error(`RedisClientDriver error: ${ JSON.stringify(err) }`);
      this.client = null;
    }
  }

  getClient() {
    if (!this.client || this.client.closing) {
      this.init();
    }
    return this.client;
  }

  initializeClient() {
    const redisOptions = {};
    if (this.credentials.ca_base64) {
      redisOptions.tls = { ca: Buffer.from(this.credentials.ca_base64, 'base64').toString('utf-8') };
    } else if (this.credentials.tls) {
      redisOptions.tls = {
        host: this.credentials.hostname || this.credentials.tls.host || this.credentials.tls.hostname,
        port: this.credentials.port || this.credentials.tls.port
      };
      redisOptions.password = this.credentials.password;
    } else if (this.credentials.sentinel_nodes && this.credentials.sentinel_nodes.length > 0) {
      redisOptions.name = (this.credentials.uri && this.credentials.uri.split('#')[1]) || 'mymaster';
      redisOptions.sentinels = this.credentials.sentinel_nodes.map(node => ({
        port: node.port,
        host: node.hostname
      }));
      redisOptions.password = this.credentials.password;
    } else {
      redisOptions.host = this.credentials.hostname;
      redisOptions.port = this.credentials.port;
      redisOptions.password = this.credentials.password;
    }

    redisOptions.retryStrategy = this.retryStrategy.bind(this);

    redisOptions.showFriendlyErrorStack = process.env.DEV_ENV_TRACES === 'true';

    redisOptions.maxRetriesPerRequest = 2;

    tracer.debug(`initializeClient - Initializing with options: ${ JSON.stringify(
      // eslint-disable-next-line eqeqeq
      redisOptions, (key, value) => key === 'password' && value != null ? '***' : value, 2) }`);

    return new Redis(redisOptions);
  }

  retryStrategy(times) {
    tracer.debug(`addRetryStrategy - retryStrategy times ${ times }`);
    let timeout;
    if (times < 3) {
      timeout = Math.min(times * RETRY_TIMEOUT_MULTIPLIER, DEFAULT_RETRY_TIMEOUT);
    } else {
      this.client = null;
    }
    return timeout;
  }

  initializeClusterClient() {
    const startupNodes = [ {
      port: this.credentials.port || this.credentials.tls.port,
      host: this.credentials.hostname || this.credentials.tls.host || this.credentials.tls.hostname
    } ];

    tracer.debug(`initializeClusterClient - initializeClusterClient startup nodes - ${ startupNodes }`);

    return new Redis.Cluster(startupNodes, {
      dnsLookup: (address, callback) => callback(null, address),
      scaleReads: REDIS_SCALE_READS,
      clusterRetryStrategy: this.retryStrategy.bind(this),
      redisOptions: {
        tls: {},
        password: this.credentials.password,
      }
    });
  }

}

module.exports.RedisClientDriver = RedisClientDriver;

let redisDriver;

module.exports.getClient = (name) => {
  if (!redisDriver) {
    redisDriver = new RedisClientDriver(vcapUtils.getServiceCredentials({ name }));
  }
  return redisDriver.getClient();
};